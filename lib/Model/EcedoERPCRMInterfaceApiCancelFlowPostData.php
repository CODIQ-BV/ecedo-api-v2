<?php
/**
 * EcedoERPCRMInterfaceApiCancelFlowPostData
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Ecedo.ERP.UI.Web Core
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1-core
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.29
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * EcedoERPCRMInterfaceApiCancelFlowPostData Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EcedoERPCRMInterfaceApiCancelFlowPostData implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Ecedo.ERP.CRM.Interface.Api.CancelFlowPostData';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'remove_connections' => 'bool',
        'termination_fee_not_applicable' => 'bool',
        'cancel_contracts' => 'bool',
        'customer_cancellation_date' => '\DateTime',
        'contract_cancellation_reason' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'remove_connections' => null,
        'termination_fee_not_applicable' => null,
        'cancel_contracts' => null,
        'customer_cancellation_date' => 'date',
        'contract_cancellation_reason' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'remove_connections' => 'RemoveConnections',
        'termination_fee_not_applicable' => 'TerminationFeeNotApplicable',
        'cancel_contracts' => 'CancelContracts',
        'customer_cancellation_date' => 'CustomerCancellationDate',
        'contract_cancellation_reason' => 'ContractCancellationReason'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'remove_connections' => 'setRemoveConnections',
        'termination_fee_not_applicable' => 'setTerminationFeeNotApplicable',
        'cancel_contracts' => 'setCancelContracts',
        'customer_cancellation_date' => 'setCustomerCancellationDate',
        'contract_cancellation_reason' => 'setContractCancellationReason'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'remove_connections' => 'getRemoveConnections',
        'termination_fee_not_applicable' => 'getTerminationFeeNotApplicable',
        'cancel_contracts' => 'getCancelContracts',
        'customer_cancellation_date' => 'getCustomerCancellationDate',
        'contract_cancellation_reason' => 'getContractCancellationReason'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const CONTRACT_CANCELLATION_REASON_WITHIN_COOLING_DOWN_PERIOD = 'WithinCoolingDownPeriod';
    const CONTRACT_CANCELLATION_REASON_NON_PAYMENT = 'NonPayment';
    const CONTRACT_CANCELLATION_REASON_MISREPRESENTATION = 'Misrepresentation';
    const CONTRACT_CANCELLATION_REASON_INVALID_SWITCH_IN = 'InvalidSwitchIn';
    const CONTRACT_CANCELLATION_REASON_CONTRACT_TAKEOVER = 'ContractTakeover';
    const CONTRACT_CANCELLATION_REASON_MOVE = 'Move';
    const CONTRACT_CANCELLATION_REASON_CANCELLATION_WITHOUT_TERMINATION_FEE = 'CancellationWithoutTerminationFee';
    const CONTRACT_CANCELLATION_REASON_DISSATISFIED = 'Dissatisfied';
    const CONTRACT_CANCELLATION_REASON_NOT_CREDITWORTHY = 'NotCreditworthy';
    const CONTRACT_CANCELLATION_REASON_WRONG_CONNECTION = 'WrongConnection';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getContractCancellationReasonAllowableValues()
    {
        return [
            self::CONTRACT_CANCELLATION_REASON_WITHIN_COOLING_DOWN_PERIOD,
            self::CONTRACT_CANCELLATION_REASON_NON_PAYMENT,
            self::CONTRACT_CANCELLATION_REASON_MISREPRESENTATION,
            self::CONTRACT_CANCELLATION_REASON_INVALID_SWITCH_IN,
            self::CONTRACT_CANCELLATION_REASON_CONTRACT_TAKEOVER,
            self::CONTRACT_CANCELLATION_REASON_MOVE,
            self::CONTRACT_CANCELLATION_REASON_CANCELLATION_WITHOUT_TERMINATION_FEE,
            self::CONTRACT_CANCELLATION_REASON_DISSATISFIED,
            self::CONTRACT_CANCELLATION_REASON_NOT_CREDITWORTHY,
            self::CONTRACT_CANCELLATION_REASON_WRONG_CONNECTION,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['remove_connections'] = isset($data['remove_connections']) ? $data['remove_connections'] : null;
        $this->container['termination_fee_not_applicable'] = isset($data['termination_fee_not_applicable']) ? $data['termination_fee_not_applicable'] : null;
        $this->container['cancel_contracts'] = isset($data['cancel_contracts']) ? $data['cancel_contracts'] : null;
        $this->container['customer_cancellation_date'] = isset($data['customer_cancellation_date']) ? $data['customer_cancellation_date'] : null;
        $this->container['contract_cancellation_reason'] = isset($data['contract_cancellation_reason']) ? $data['contract_cancellation_reason'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getContractCancellationReasonAllowableValues();
        if (!is_null($this->container['contract_cancellation_reason']) && !in_array($this->container['contract_cancellation_reason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'contract_cancellation_reason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets remove_connections
     *
     * @return bool
     */
    public function getRemoveConnections()
    {
        return $this->container['remove_connections'];
    }

    /**
     * Sets remove_connections
     *
     * @param bool $remove_connections Optionele parameter (default false). Als deze parameter true is wordt een poging gedaan om de aansluitingen van de aanmeldflow te verwijderen. Dit is alleen mogelijk als CancelContracts ook true is.
     *
     * @return $this
     */
    public function setRemoveConnections($remove_connections)
    {
        $this->container['remove_connections'] = $remove_connections;

        return $this;
    }

    /**
     * Gets termination_fee_not_applicable
     *
     * @return bool
     */
    public function getTerminationFeeNotApplicable()
    {
        return $this->container['termination_fee_not_applicable'];
    }

    /**
     * Sets termination_fee_not_applicable
     *
     * @param bool $termination_fee_not_applicable Optionele parameter (default false). Als deze parameter true is wordt er geen opzegvergoeding in rekening gebracht. Als deze parameter false is wordt er gekeken of er een opzegvergoeding in rekening gebracht moet worden.
     *
     * @return $this
     */
    public function setTerminationFeeNotApplicable($termination_fee_not_applicable)
    {
        $this->container['termination_fee_not_applicable'] = $termination_fee_not_applicable;

        return $this;
    }

    /**
     * Gets cancel_contracts
     *
     * @return bool
     */
    public function getCancelContracts()
    {
        return $this->container['cancel_contracts'];
    }

    /**
     * Sets cancel_contracts
     *
     * @param bool $cancel_contracts Optionele parameter (default true). Als deze parameter true is worden de statussen van de aansluitingen op \"Aanmelding afgebroken\" gezet, als dat niet het geval is krijgen de aansluitingen de status \"Aangemaakt\". Daarnaast worden contracten van de aansluitingen van de aanmeldflow geannuleerd. Doordat de contracten geannuleerd worden, worden eventuele contract-factuuritems (ContractBillingItems) ook geannuleerd en worden er ContractCancelled-triggers verstuurd.
     *
     * @return $this
     */
    public function setCancelContracts($cancel_contracts)
    {
        $this->container['cancel_contracts'] = $cancel_contracts;

        return $this;
    }

    /**
     * Gets customer_cancellation_date
     *
     * @return \DateTime
     */
    public function getCustomerCancellationDate()
    {
        return $this->container['customer_cancellation_date'];
    }

    /**
     * Sets customer_cancellation_date
     *
     * @param \DateTime $customer_cancellation_date Optionele parameter (default 'vandaag'). Als de parameter TerminationFeeNotApplicable false is wordt gekeken of er een opzegvergoeding in rekening gebracht moet worden. Daarvoor wordt onder andere gekeken wanneer de klant het contract heeft opgezegd. Met behulp van deze parameter kan aangegeven worden op welke datum dat was.
     *
     * @return $this
     */
    public function setCustomerCancellationDate($customer_cancellation_date)
    {
        $this->container['customer_cancellation_date'] = $customer_cancellation_date;

        return $this;
    }

    /**
     * Gets contract_cancellation_reason
     *
     * @return string
     */
    public function getContractCancellationReason()
    {
        return $this->container['contract_cancellation_reason'];
    }

    /**
     * Sets contract_cancellation_reason
     *
     * @param string $contract_cancellation_reason Optioneel veld (default null). Als CancelContracts true is kan met behulp van deze variabele een reden voor de opzegging worden meegegeven. Deze reden wordt ter registratie gebruikt.
     *
     * @return $this
     */
    public function setContractCancellationReason($contract_cancellation_reason)
    {
        $allowedValues = $this->getContractCancellationReasonAllowableValues();
        if (!is_null($contract_cancellation_reason) && !in_array($contract_cancellation_reason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'contract_cancellation_reason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['contract_cancellation_reason'] = $contract_cancellation_reason;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


