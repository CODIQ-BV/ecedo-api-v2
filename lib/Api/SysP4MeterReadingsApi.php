<?php
/**
 * SysP4MeterReadingsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Ecedo.ERP.UI.Web Core
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1-core
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.29
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * SysP4MeterReadingsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SysP4MeterReadingsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation sysP4MeterReadingsGetByConnectionId
     *
     * Get readings voor connectieId, type en periode.
     *
     * @param  string $connection_id  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings
     */
    public function sysP4MeterReadingsGetByConnectionId($connection_id, $type, $start_date, $end_date = null)
    {
        list($response) = $this->sysP4MeterReadingsGetByConnectionIdWithHttpInfo($connection_id, $type, $start_date, $end_date);
        return $response;
    }

    /**
     * Operation sysP4MeterReadingsGetByConnectionIdWithHttpInfo
     *
     * Get readings voor connectieId, type en periode.
     *
     * @param  string $connection_id  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings, HTTP status code, HTTP response headers (array of strings)
     */
    public function sysP4MeterReadingsGetByConnectionIdWithHttpInfo($connection_id, $type, $start_date, $end_date = null)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetByConnectionIdRequest($connection_id, $type, $start_date, $end_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sysP4MeterReadingsGetByConnectionIdAsync
     *
     * Get readings voor connectieId, type en periode.
     *
     * @param  string $connection_id  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetByConnectionIdAsync($connection_id, $type, $start_date, $end_date = null)
    {
        return $this->sysP4MeterReadingsGetByConnectionIdAsyncWithHttpInfo($connection_id, $type, $start_date, $end_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sysP4MeterReadingsGetByConnectionIdAsyncWithHttpInfo
     *
     * Get readings voor connectieId, type en periode.
     *
     * @param  string $connection_id  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetByConnectionIdAsyncWithHttpInfo($connection_id, $type, $start_date, $end_date = null)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetByConnectionIdRequest($connection_id, $type, $start_date, $end_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sysP4MeterReadingsGetByConnectionId'
     *
     * @param  string $connection_id  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sysP4MeterReadingsGetByConnectionIdRequest($connection_id, $type, $start_date, $end_date = null)
    {
        // verify the required parameter 'connection_id' is set
        if ($connection_id === null || (is_array($connection_id) && count($connection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_id when calling sysP4MeterReadingsGetByConnectionId'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling sysP4MeterReadingsGetByConnectionId'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling sysP4MeterReadingsGetByConnectionId'
            );
        }

        $resourcePath = '/sysapi/v1.0/P4MeterReadings/{connectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date);
        }

        // path params
        if ($connection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'connectionId' . '}',
                ObjectSerializer::toPathValue($connection_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sysP4MeterReadingsGetByEan
     *
     * Get readings voor ean, type en periode.
     *
     * @param  string $ean  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings
     */
    public function sysP4MeterReadingsGetByEan($ean, $type, $start_date, $end_date = null)
    {
        list($response) = $this->sysP4MeterReadingsGetByEanWithHttpInfo($ean, $type, $start_date, $end_date);
        return $response;
    }

    /**
     * Operation sysP4MeterReadingsGetByEanWithHttpInfo
     *
     * Get readings voor ean, type en periode.
     *
     * @param  string $ean  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings, HTTP status code, HTTP response headers (array of strings)
     */
    public function sysP4MeterReadingsGetByEanWithHttpInfo($ean, $type, $start_date, $end_date = null)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetByEanRequest($ean, $type, $start_date, $end_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sysP4MeterReadingsGetByEanAsync
     *
     * Get readings voor ean, type en periode.
     *
     * @param  string $ean  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetByEanAsync($ean, $type, $start_date, $end_date = null)
    {
        return $this->sysP4MeterReadingsGetByEanAsyncWithHttpInfo($ean, $type, $start_date, $end_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sysP4MeterReadingsGetByEanAsyncWithHttpInfo
     *
     * Get readings voor ean, type en periode.
     *
     * @param  string $ean  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetByEanAsyncWithHttpInfo($ean, $type, $start_date, $end_date = null)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetByEanRequest($ean, $type, $start_date, $end_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sysP4MeterReadingsGetByEan'
     *
     * @param  string $ean  (required)
     * @param  string $type  (required)
     * @param  \DateTime $start_date startdatum voor opvragen periode (required)
     * @param  \DateTime $end_date einddatum voor opvragen periode. Indien niet gevuld worden alleen readings op startdatum teruggegeven. Periode is gemaximaliseerd op 31 dagen voor intervalstanden. Bij dagstanden geldt een maximale periode van 366 dagen. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sysP4MeterReadingsGetByEanRequest($ean, $type, $start_date, $end_date = null)
    {
        // verify the required parameter 'ean' is set
        if ($ean === null || (is_array($ean) && count($ean) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ean when calling sysP4MeterReadingsGetByEan'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling sysP4MeterReadingsGetByEan'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling sysP4MeterReadingsGetByEan'
            );
        }

        $resourcePath = '/sysapi/v1.0/P4MeterReadings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ean !== null) {
            $queryParams['ean'] = ObjectSerializer::toQueryValue($ean);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sysP4MeterReadingsGetByReadingIds
     *
     * Get readings op basis van p4readingIds.
     *
     * @param  string[] $reading_ids P4ReadingIds (required)
     * @param  string $type  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings
     */
    public function sysP4MeterReadingsGetByReadingIds($reading_ids, $type)
    {
        list($response) = $this->sysP4MeterReadingsGetByReadingIdsWithHttpInfo($reading_ids, $type);
        return $response;
    }

    /**
     * Operation sysP4MeterReadingsGetByReadingIdsWithHttpInfo
     *
     * Get readings op basis van p4readingIds.
     *
     * @param  string[] $reading_ids P4ReadingIds (required)
     * @param  string $type  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings, HTTP status code, HTTP response headers (array of strings)
     */
    public function sysP4MeterReadingsGetByReadingIdsWithHttpInfo($reading_ids, $type)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetByReadingIdsRequest($reading_ids, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sysP4MeterReadingsGetByReadingIdsAsync
     *
     * Get readings op basis van p4readingIds.
     *
     * @param  string[] $reading_ids P4ReadingIds (required)
     * @param  string $type  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetByReadingIdsAsync($reading_ids, $type)
    {
        return $this->sysP4MeterReadingsGetByReadingIdsAsyncWithHttpInfo($reading_ids, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sysP4MeterReadingsGetByReadingIdsAsyncWithHttpInfo
     *
     * Get readings op basis van p4readingIds.
     *
     * @param  string[] $reading_ids P4ReadingIds (required)
     * @param  string $type  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetByReadingIdsAsyncWithHttpInfo($reading_ids, $type)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetByReadingIdsRequest($reading_ids, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sysP4MeterReadingsGetByReadingIds'
     *
     * @param  string[] $reading_ids P4ReadingIds (required)
     * @param  string $type  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sysP4MeterReadingsGetByReadingIdsRequest($reading_ids, $type)
    {
        // verify the required parameter 'reading_ids' is set
        if ($reading_ids === null || (is_array($reading_ids) && count($reading_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reading_ids when calling sysP4MeterReadingsGetByReadingIds'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling sysP4MeterReadingsGetByReadingIds'
            );
        }

        $resourcePath = '/sysapi/v1.0/P4MeterReadings/readingIds/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($reading_ids)) {
            $queryParams['readingIds'] = $reading_ids;
        } else
        if ($reading_ids !== null) {
            $queryParams['readingIds'] = ObjectSerializer::toQueryValue($reading_ids);
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsn
     *
     * Verkrijg historische dagstanden van EDSN. De klant moet toestemming hebben gegeven om dit op te mogen vragen
     *
     * @param  string $connection_id  (required)
     * @param  \DateTime $start_date  (required)
     * @param  \DateTime $end_date wanneer niet wordt meegegeven dan wordt de huidige datum genomen (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\EcedoERPCRMInterfaceApiDayP4MeterReadings
     */
    public function sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsn($connection_id, $start_date, $end_date = null)
    {
        list($response) = $this->sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnWithHttpInfo($connection_id, $start_date, $end_date);
        return $response;
    }

    /**
     * Operation sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnWithHttpInfo
     *
     * Verkrijg historische dagstanden van EDSN. De klant moet toestemming hebben gegeven om dit op te mogen vragen
     *
     * @param  string $connection_id  (required)
     * @param  \DateTime $start_date  (required)
     * @param  \DateTime $end_date wanneer niet wordt meegegeven dan wordt de huidige datum genomen (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\EcedoERPCRMInterfaceApiDayP4MeterReadings, HTTP status code, HTTP response headers (array of strings)
     */
    public function sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnWithHttpInfo($connection_id, $start_date, $end_date = null)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiDayP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnRequest($connection_id, $start_date, $end_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiDayP4MeterReadings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\EcedoERPCRMInterfaceApiErrorMessage401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnAsync
     *
     * Verkrijg historische dagstanden van EDSN. De klant moet toestemming hebben gegeven om dit op te mogen vragen
     *
     * @param  string $connection_id  (required)
     * @param  \DateTime $start_date  (required)
     * @param  \DateTime $end_date wanneer niet wordt meegegeven dan wordt de huidige datum genomen (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnAsync($connection_id, $start_date, $end_date = null)
    {
        return $this->sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnAsyncWithHttpInfo($connection_id, $start_date, $end_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnAsyncWithHttpInfo
     *
     * Verkrijg historische dagstanden van EDSN. De klant moet toestemming hebben gegeven om dit op te mogen vragen
     *
     * @param  string $connection_id  (required)
     * @param  \DateTime $start_date  (required)
     * @param  \DateTime $end_date wanneer niet wordt meegegeven dan wordt de huidige datum genomen (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnAsyncWithHttpInfo($connection_id, $start_date, $end_date = null)
    {
        $returnType = '\Swagger\Client\Model\EcedoERPCRMInterfaceApiDayP4MeterReadings';
        $request = $this->sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnRequest($connection_id, $start_date, $end_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsn'
     *
     * @param  string $connection_id  (required)
     * @param  \DateTime $start_date  (required)
     * @param  \DateTime $end_date wanneer niet wordt meegegeven dan wordt de huidige datum genomen (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsnRequest($connection_id, $start_date, $end_date = null)
    {
        // verify the required parameter 'connection_id' is set
        if ($connection_id === null || (is_array($connection_id) && count($connection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_id when calling sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsn'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling sysP4MeterReadingsGetHistoricalDayP4MeterReadingsFromEdsn'
            );
        }

        $resourcePath = '/sysapi/v1.0/HistoricalDayReadings/{connectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date);
        }

        // path params
        if ($connection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'connectionId' . '}',
                ObjectSerializer::toPathValue($connection_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
